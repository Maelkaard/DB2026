# Занятие №2. Основы SQL, DML операторы

SQL (Structured Query Language) - язык программирования, служащий для написания запросов к реляционным базам данных. Иногда синтаксис запроса зависит от конкретной СУБД, к которой обращен запрос, поэтому отметим, что здесь и далее работать мы будем с СУБД PostgreSQL.

Первое, что мы узнаем из SQL - как работать с данными. Для этого служит группа операторов языка, называемая DML (Data Manipulation Language)

Почему начинаем с работы с данными, а не с их организации? Потому что знания о работе с данными позволяют узнавать результаты всех остальный действий с БД, что будет крайне полезно во всех дальнейших темах.

## Создание таблицы

Для работы с данными создадим простую таблицу: 

```sql
-- Создание схемы
CREATE SCHEMA school;

-- Создание таблицы в схеме school
CREATE TABLE school.students (
    student_id INTEGER, --целочисленное значение
    name VARCHAR(100), --строковое значение до 100 символов
    age INTEGER
);
```
Более детально процесс создания таблиц, а также что такое схема и зачем она нужна, мы рассмотрим позже, а сейчас важно то, что мы создали таблицу под названием school.students с тремя столбцами (атрибутами) - student_id, name, age, и указали их тип данных.

## Вставка данных

Теперь необходимо заполнить таблицу данными. Для этого используется оператор INSERT:

```sql
-- Вставка данных в таблицу school.students
INSERT INTO school.students (student_id, name, age) --имя таблицы и атрибуты, значения которых вставляем
    VALUES --виртуальная таблица
    (1, 'Alex', 16),
    (2, 'Billy', 18),
    (3, 'Chris', 17),
    (4, 'David', 18),
    (5, 'Eugene', 16);
```
Что же такое VALUES? Это оператор, который возвращает виртуальную таблицу констант, которая после этого вставляется оператором INSERT. Позже мы узнаем другие способы создавать подобные виртуальные таблицы, содержащие не только константы.

_Note_. Виртуальными таблицами здесь и далее мы будем называть любой набор данных, имеющий структуру таблицы, но не хранящийся в памяти.

## Вывод данных

Теперь, когда у нас есть созданная таблица, наполненная какими-то данными, мы можем выполнить основное действие, возникающее при работе с данными - их вывод. Для этого используется оператор SELECT:

```sql
SELECT student_id, name, age --заголовок вывода
FROM school.students; --источник данных
```
Такой запрос вернет нам все содержимое таблицы school.students:

| student_id | name  | age |
|------------|-------|-----|
| 1          | Alex  | 16  |
| 2          | Billy | 18  |
| 3          | Chris | 17  |
| 4          | David | 18  |
| 5          | Eugene| 16  |

_Note_. SELECT также как и VALUES создает виртуальную таблицу, которая по умолчанию выводится в консоль. Результат SELECT-запроса можно вставить в таблицу при помощи INSERT, заменив в рассмотренном синтаксисе VALUES ... на SELECT ...

В заголовке вывода перечисляются все атрибуты, значения которых мы хотим вывести, в данном случае все. Также существует краткая форма записи для вывода всех атрибутов:

```sql
SELECT *
FROM school.students;
```
Указывая только часть атрибутов из заголовка таблицы в SELECT, получаем аналог операции проекции из реляционной алгебры:

```sql
SELECT name, age
FROM school.students;
```
| name  | age |
|-------|-----|
| Alex  | 16  |
| Billy | 18  |
| Chris | 17  |
| David | 18  |
| Eugene| 16  |

_Note_. Реляционная алгебра - лишь теоретическая основа реляционных баз данных, и таблица реляционной базы данных (хранимая или виртуальная) не является полноценным отношением в смысле реляционной алгебры, а именно не поддерживает свойство уникальности кортежей в содержимом. При выполнении операции
```sql
SELECT age
FROM school.students;
```
мы получим

| age |
|-----|
| 16  |
| 18  |
| 17  |
| 18  |
| 16  |

т.е. таблицу с повторяющимися строками. Однозначность адресации в реальных базах данных выполняется "под капотом" независимо от содержимого


## Структура SELECT-запроса

Оператор SELECT имеет много разных опций, дающих возможность выводить необходимую информацию.
Общая структура SELECT-запроса выглядит следующим образом:
```sql
SELECT [DISTINCT | DISTINCT ON (column, ...)] column1, column2, ...
FROM table_name
[WHERE condition]
[GROUP BY column]
[HAVING condition]
[ORDER BY column [DESC]]
[LIMIT | OFFSET number];
```
1. **SELECT**: Заголовок вывода. Может содержать названия столбцов таблицы, константы и выражения, составленные из них. Использование DISTINCT позволяет вывести только уникальные строки, DISTINCT ON (column1, column2, ...) - вывести только строки, уникальные по значениям выбранных атрибутов
2. **FROM**: Указывает источник данных (например таблицу), из которого выбираются данные.
3. **WHERE**: (необязательный) Фильтрует строки на основе заданного условия. condition - выражение, возвращающее логическое значение; в вывод попадут только строки, для которых оно возвращает TRUE. Само выражение может содержать названия столбцов (в выражении будут использованы их значения для конкретной строки) и константы.
4. **GROUP BY**: (необязательный) Группирует строки по указанным столбцам для агрегирования данных. Группировка происходит на основе равенства значений в выбранных столбцах. В случае наличия в запросе GROUP BY в заголовке вывода могут быть использованы только столбцы, по которым была выполнена группировка; значения остальных могут быть выведены только при использовании агрегатных функций (например max()). В итоговом выводе каждой группе будет соответствовать ровно 1 строка.
5. **HAVING**: (необязательный) Фильтрует группы, созданные с помощью GROUP BY, на основе заданного условия. condition - выражение, возвращающее логическое значение; в вывод попадут только группы, для которых оно возвращает TRUE. В выражении могут быть использованы только столбцы, по которым была выполнена группировка, а также агрегатные функции от других столбцов и константы.
6. **ORDER BY**: (необязательный) Указывает порядок сортировки результатов по одному или нескольким столбцам. Сортировка по второму из указанных столбцов происходит внутри блоков строк, равных по первому столбцу, третий и далее - аналогично. По умолчанию сортировка по возрастанию, для сортировки по убыванию необходимо после имени столбца указать DESC (таким образом направление сортировки указывается для каждого столбца отдельно). Если используется одновременно с DISTINCT ON, то атрибуты, по которым необходима уникальность, указываются в числе атрибутов сортировки в начале.
7. **LIMIT / OFFSET**: (необязательный) Ограничивает количество возвращаемых строк. LIMIT N приведет к выводу не более чем N первых (с точки зрения сортировки) строк, OFFSET N - выводу всех строк кроме N первых, с точки зрения сортировки. В случае отсутствия сортировки (ORDER BY) в запросе порядок формально не опеределен, и выведенные строки являются формально непредсказуемыми. В случае наличия в запросе и LIMIT, и OFFSET, например LIMIT N OFFSET M, будут выведены строки с M+1 до M+N. 

## Примеры:

```sql
SELECT student_id, name, age
FROM school.students
WHERE age = 18;
```
| student_id | name  | age |
| ---------- | ----- | --- |
| 2          | Billy | 18  |
| 4          | David | 18  |

```sql
SELECT DISTINCT age
FROM school.students;
```
| age |
| --- |
| 16  |
| 18  |
| 17  |
```sql
SELECT name, age
FROM school.students
ORDER BY age;
```
| name   | age |
| ------ | --- |
| Alex   | 16  |
| Eugene | 16  |
| Chris  | 17  |
| Billy  | 18  |
| David  | 18  |
```sql
SELECT name, age
FROM school.students
ORDER BY age DESC
LIMIT 3;
```
| name  | age |
| ----- | --- |
| Billy | 18  |
| David | 18  |
| Chris | 17  |
```sql
SELECT age, COUNT(*) AS count
FROM school.students
GROUP BY age;
```
| age | count |
| --- | ----- |
| 16  | 2     |
| 18  | 2     |
| 17  | 1     |
```sql
SELECT age, COUNT(*) AS count
FROM school.students
GROUP BY age
HAVING COUNT(*) > 1;
```
| age | count |
| --- | ----- |
| 16  | 2     |
| 18  | 2     |
## Агрегатные функции
В SQL используются следующие основные агрегатные функции:
  1. AVG(attr): вычисляет среднее значение атрибута attr
  2. COUNT(*): вычисляет количество строк _(COUNT() с другими агрументами будет рассмотрен позднее)_
  3. MAX(attr): вычисляет максимальное значение атрибута attr
  4. MIN(attr): вычисляет минимальное значение атрибута attr
  5. SUM(attr): вычисляет сумму значений атрибута attr
## Изменение данных
Для изменения содержимого таблицы используется оператор UPDATE:
```sql
UPDATE table_name
SET column1 = value1, column2 = value2, ...
WHERE condition;
```
Изменения применяются ко всем строкам, для которых condition возвращает TRUE.\
Например
```sql
UPDATE school.students
SET age = 19
WHERE student_id = 2;

SELECT *
FROM school.students
ORDER BY student_id;
```
| student_id | name  | age |
|------------|-------|-----|
| 1          | Alex  | 16  |
| 2          | Billy | 19  |
| 3          | Chris | 17  |
| 4          | David | 18  |
| 5          | Eugene| 16  |
## Удаление данных
Для построчного удаления строк из таблицы используется оператор DELETE:
```sql
DELETE FROM table_name
WHERE condition;
```
Удаляются те строки, для которых condition возвращает TRUE.\
Например
```sql
DELETE FROM school.students
WHERE age < 17;

SELECT *
FROM school.students
ORDER BY student_id;
```
| student_id | name  | age |
|------------|-------|-----|
| 2          | Billy | 19  |
| 3          | Chris | 17  |
| 4          | David | 18  |

## Практические задания


Во всех заданиях используется таблица `shop.orders` (заказы) со следующими полями:

* `order_id` - идентификатор заказа
* `customer_name` - имя клиента
* `city` - город клиента
* `order_date` - дата заказа
* `status` - статус заказа
* `amount` - сумма заказа
* `discount` - скидка на заказ, в процентах

Скрипт для создания таблицы и ее заполнения приложен в папку семинара.

Атрибут `order_date` имеет тип DATE. Более подробно этот и другие типы данных мы рассмотрим позднее, сейчас важно знать, что дата записывается в виде строки в формате `'yyyy-mm-dd'`.

## Задание 1

Вывести идентификатор заказа, имя клиента и сумму заказа для заказов со статусом `paid`, у которых сумма больше 100.
Отсортировать результат по сумме по убыванию.

### Решение

```sql
SELECT order_id, customer_name, amount
FROM shop.orders
WHERE status = 'paid' AND amount > 100
ORDER BY amount DESC;
```

---

## Задание 2

Для каждого города вывести количество заказов и среднюю сумму заказа. Отсортировать по количеству заказов по убыванию.

### Решение

```sql
SELECT
    city,
    COUNT(*) AS orders_count,
    AVG(amount) AS avg_amount
FROM shop.orders
GROUP BY city
ORDER BY orders_count DESC;
```

---

## Задание 3

Установить скидку в 10 процентов для всех заказов со статусом `'new'`, у которых сумма заказа не меньше 200.

### Решение

```sql
UPDATE shop.orders
SET discount = 10
WHERE status = 'new' AND amount >= 200;
```

---

## Задание 4

Вывести идентификатор заказа, имя клиента и сумму для заказов, сделанных в городе `'Berlin'` и имеющих сумму от 50 до 300 включительно.

---

## Задание 5

Вывести уникальные значения статусов заказов, присутствующих в таблице.

---

## Задание 6

Вывести для заказов со статусами `'paid'` и `'shipped'` их идентификаторы, статусы и сумму заказа.

---

## Задание 7

Вывести заказы, у которых сумма превышает 300, а скидка не превосходит 10.

---

## Задание 8

Вывести для 5 самых дорогих заказов их идентификатор, имя клиента и сумму заказа.

---

## Задание 9

Вывести клиентов, у которых средняя сумма заказа превышает 150.

---

## Задание 10

Посчитать общее количество заказов и суммарную стоимость всех заказов.

---

## Задание 11

Для каждого статуса вывести количество заказов.

---

## Задание 12

Для каждого клиента вывести суммарную стоимость всех его заказов.

---

## Задание 13

Вывести города, в которых количество заказов больше 100

---

## Задание 14

Вывести заказы с 3-го по 6-й по величине суммы (по убыванию суммы)

---

## Задание 15

Вывести заказы, отсортированные сначала по дате по возрастанию,
а внутри одной даты — по сумме заказа по убыванию.

---

## Задание 16

Установить статус `'cancelled'` всем заказам со статусом `'new'`,
сделанным раньше даты `'2025-01-01'`.

---

## Задание 17

Увеличить сумму заказа на 5% для всех заказов со статусом `'paid'`.

---

## Задание 18

Удалить все заказы со статусом `'cancelled'`.

---

## Задание 19

Удалить заказы со статусом `'shipped'`, у которых сумма меньше 10.

---

## Задание 20

Удалить заказы со статусом `'new'`,
если у них скидка равна 0 или сумма заказа меньше 50.

---
