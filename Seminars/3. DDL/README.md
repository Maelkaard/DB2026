# Занятие №3. DDL операторы & JOIN

DDL - группа операторов, используемая для создания, изменения и удаления объектов базы данных (таких как схема или таблица)

## Оператор CREATE

CREATE - оператор создания объекта. На прошлом семинаре он уже использовался, но сейчас мы рассмотрим его подробнее. Сначала создадим схему:

```sql
CREATE SCHEMA cinema;
```
Схема выделяет внутри базы данных на сервере изолированное пространство имен. Все таблицы и прочие объекты создаются внутри схемы, что позволяет использовать в различных схемах совпадающие имена объектов.

Увидеть все схемы, существующие в БД, можно при помощи команды

```sql
SELECT schema_name
FROM information_schema.schemata;
```

Для создания таблицы используется CREATE TABLE:

```sql
CREATE TABLE cinema.movies (
    movie_id      INTEGER,  --<название> <тип данных>
    title         VARCHAR(200),
    release_year  INTEGER,
    duration_min  INTEGER,
    rating        NUMERIC(3,1)
);
```

Увидеть все таблицы, существующие в схеме, можно при помощи команды

```sql
SELECT table_name
FROM information_schema.tables
WHERE table_schema = <schema_name>
  AND table_type = 'BASE TABLE';
```

## Типы данных

Рассмотрим основные типы данных, существующих в PostgreSQL:

| Категория | Тип | Описание |
|----------|-----|----------|
| **Целочисленные** | SMALLINT | 2-байтное целое число |
|  | INTEGER / INT | 4-байтное целое число |
|  | BIGINT |8-байтное целое число |
| **Дробные** | NUMERIC(p, s) / DECIMAL(p, s)| Дробное число с заданной точностью - не более s цифр после запятой, не более чем p-s цифр перед запятой (таким образом не более p цифр всего)|
|  | REAL | 4-байтное число с плавающей точкой |
|  | DOUBLE PRECISION / FLOAT | 8-байтное число с плавающей точкой |
| **Строковые** | CHAR(n) | Строка длины n |
|  | VARCHAR(n) | Строка длины не более n |
|  | TEXT | Строка произвольной длины ||
| **Дата и время** | DATE | Дата | 2025-01-30 |
|  | TIME | Время | 14:30:00 |
|  | TIMESTAMP | Дата и время | 2025-01-30 14:30:00 |
|  | TIMESTAMPTZ | Дата и время с часовым поясом | 2025-01-30 14:30:00+02 |
|  | INTERVAL | Промежуток времени |
| **Логический** | BOOLEAN / BOOL| Логическое значение |
| **Бинарный** | BYTEA | Бинарные данные |
| **JSON** | JSON | JSON-текст | {"a":1} |

## NOT NULL

Запрет атрибуту принимать значение NULL. Указывается после указания типа данных атрибута.

## Значения по умолчанию

Значение атрибута по умолчанию, то есть значение, которое будет присвоено атрибуту в случае, если его значение не передано, указывается через ключевое слово DEFAULT после указания типа данных атрибута.

## Числовые типы с автоинкрементом

Для создания гарантированно уникальных значений (например, для первичных ключей) часто используются числовые типы с автоинкрементом - SMALLSERIAL, SERIAL и BIGSERIAL, которые хранят числа в диапазоне соответственно SMALLINT, INT и BIGINT. Значение атрибута такого типа при вставке строки не передается, и он автоматически принимает значение, равное значению в ранее вставленной строке, увеличенному на 1.

_Note:_ На самом деле, такие типы реализуются через специальные объекты SEQUENCE. Такой объект содержит текущее значение и шаг роста последовательности, и обладает функциями для возвращения значения и перехода на следующее значение. При создании атрибута, имеющего тип с автоинкрементом, на самом деле создается обычный целочисленный атрибут, но со значением по умолчанию, равным nextval(sequence), т.е. каждый раз при непередаче значения атрибута происходит шаг последовательности и возврат нового значения как значения по умолчанию. Поэтому явно вставлять значения такого атрибута в таблицу можно (как и любого атрибута со значением по умолчанию), но в этом случае впоследствие может быть нарушена уникальность (если шаг последовательности дойдет до ранее вставленного явно значения).

## Ограничения

Кроме имен атрибутов и их типов в таблице также могут быть указаны ограничения. Они не позволяют помещать в таблицу (путем INSERT или UPDATE) данные, не удовлетворяющие некоторым условиям. Существуют ограничения следующих видов:
- CHECK(condition) - проверяет, что выражение возвращает для строки NOT FALSE
- UNIQUE (attr1, ...) - запрещает атрибуту (или кортежу атрибутов) принимать равные значения в 2 разных строках. По умолчанию значения NULL в 2 разных строках не нарушают это ограничение. В случае необходимости запретить хранение NULL в 2 разных строках следуюет указать UNIQUE NULLS NOT DISTINCT (attr1, ...) 
- PRIMARY KEY (attr1, ...) - создает первичный ключ. Также накладывает ограничения NOT NULL и UNIQUE, и кроме этого создает *индекс*. Может существовать не более 1 раза в таблице
- FOREIGN KEY (attr1, ...) REFERENCES table (attr2_1, ...) - создает внешний ключ на таблицу table (допускается создание FK на себя). Кортеж атрибутов, на которые ссылается ключ, должен иметь ограничение UNIQUE или PRIMARY KEY. Количество атрибутов во внешнем ключе и кортеже, на который он ссылается, должно совпадать, а их типы данных должны быть совместимы (т.е. между ними должен быть определен оператор '=')

Ограничения по умолчанию объявляются при создании таблицы после объявления всех атрибутов. Также, если добавить перед объявлением ограничения CONSTRAINT constraint_name, то можно задать ограничению имя (иначе оно будет сгенерировано по умолчанию). Также, если ограничение затрагивает только один атрибут, то задать ограничение можно в одной строке с созданием атрибута.

Создадим еще одну таблицу, сразу с ограничениями:

```sql
CREATE TABLE cinema.users (
    user_id        SERIAL PRIMARY KEY,
    email          VARCHAR(255) UNIQUE,
    full_name      VARCHAR(150) NOT NULL,
    birth_date     DATE,
    country        VARCHAR(100)
);
```
При попытке вставки в таблицу строки, нарушающей ограничения, или изменения строки таблицы так, что она будет нарушать ограничения - запрос завершится с ошибкой.

Чтобы посмотреть все ограничения, существующие в таблице, можно выполнить запрос

```sql
SELECT
    tc.constraint_name,
    tc.constraint_type,
    kcu.column_name,
    ccu.table_name AS foreign_table_name,
    ccu.column_name AS foreign_column_name
FROM information_schema.table_constraints AS tc
LEFT JOIN information_schema.key_column_usage AS kcu
       ON tc.constraint_name = kcu.constraint_name
LEFT JOIN information_schema.constraint_column_usage AS ccu
       ON ccu.constraint_name = tc.constraint_name
WHERE tc.table_name = <table_name>
  AND tc.table_schema = <schema_name>
ORDER BY tc.constraint_type, tc.constraint_name;
```

Чтобы посмотреть значения по умолчанию / NOT NULL:

```sql
SELECT
    column_name,
    is_nullable,
	column_default
FROM information_schema.columns
WHERE table_name = <table_name>
  AND table_schema = <schema_name>;
```

## Оператор ALTER

Оператор ALTER используется для изменения объектов базы данных - в нашем случае пока только таблиц. Основные возможности:
- Переименовать таблицу
```sql
ALTER TABLE name RENAME TO new_name
```
- Переименовать атрибут
```sql
ALTER TABLE name RENAME COLUMN column_name TO new_column_name
```
- Переименовать ограничение
```sql
ALTER TABLE name RENAME CONSTRAINT constraint_name TO new_constraint_name
```
- Добавить атрибут в таблицу
```sql
ALTER TABLE name ADD COLUMN column_name data_type;
```
- Удалить атрибут из таблицы
```sql
ALTER TABLE name DROP COLUMN column_name;
```
- Изменить тип данных атрибута
```sql
ALTER TABLE name ALTER COLUMN column_name SET DATA TYPE data_type;
```
- Установить для атрибута значение по умолчанию / NOT NULL
```sql
ALTER TABLE name ALTER COLUMN column_name SET DEFAULT expression;
ALTER TABLE name ALTER COLUMN column_name SET NOT NULL;
```
- Удалить у атрибута значение по умолчанию / NOT NULL
```sql
ALTER TABLE name ALTER COLUMN column_name DROP DEFAULT;
ALTER TABLE name ALTER COLUMN column_name DROP NOT NULL;
```
- Добавить ограничение
```sql
ALTER TABLE name ADD CONSTRAINT constraint_expression;
```
- Удалить ограничение
```sql
ALTER TABLE name DROP CONSTRAINT constraint_name;
```

Изменим ранее созданную таблицу 'movies':
```sql
ALTER TABLE cinema.movies
ADD COLUMN country VARCHAR(100),
ADD CONSTRAINT movies_pk PRIMARY KEY (movie_id), --действия с одной таблицей можно выполнить одним оператором ALTER
```

При попытке добавить таблице ограничение, которому не удовлетворяет хотя бы одна строка таблицы, запрос завершится с ошибкой.

## Внешние ключи

Внешний ключ отличается от других ограничений тем, что накладывает условия на строку данных в зависимости от значений в других строках данных (в этой же или другой таблице). Из определения внешнего ключа известно, что множество значений внешнего ключа - это подмножество множества значений потенциального ключа, на который он ссылается. С точки зрения SQL это означает запрет получения атрибутом - внешним ключом значения, которое отсутствует среди значений атрибута, на который он ссылается (но при этом внешний ключ может получить значение NULL в случае отсутствия других ограничений). Для поддержания этого свойства, называемого ссылочной целостностью, каждый внешний ключ обладает опцией ON DELETE, который определяет поведение строки с ключом при удалении оператором DELETE значения, на которое ссылался ключ. Значение ON DELETE по умолчанию - NO ACTION, т.е. не предпринимать никаких действий. В этом случае запрос, удаляющий значение, на которое ссылается строка с ключом, завершится с ошибкой, т.к. в результате нарушится ссылочная целостность. \
В будущем мы узнаем, как добиться того, чтобы проверка ограничений выполнялась не сразу после выполнения запроса, а отложенно, в таком случае можно будет выполнять запросы, частично нарушающие ограничения. А пока такая опция подразумевает, что любая операция удаления значения, на которое есть ссылка - это ошибка.\
Альтернативные опции:
- RESTRICT запрещает удаления значения, если на него ссылается хотя бы одна строка с внешним ключом, но при этом не провоцирует ошибку удаляющего запроса (таким образом, если запрос удалял несколько строк, удалятся только те, на значения которых нет ссылок).
- CASCADE при удалении значения, на которое ссылается хотя бы одна строка с внешним ключом, запускает операцию удаления ссылающихся на нее строк. Таким образом, после удаления значения не остается строк, ссылающихся на несуществующее значение, ссылочная целостность восстановлена. CASCADE стоит применять очень аккуратно, так как иногда сохранение данные, ссылавшихся на удаленный объект, имеет смысл
- SET NULL при удалении значения, на которое ведет ссылка, заменяет значение внешних ключей в строках, ссылавшихся на удаленное значение на NULL
- SET DEFAULT аналогичен SET NULL, но вместо NULL используется значение по умолчанию (в этом случае оно должно существовать у атрибутов внешнего ключа)

Синтаксис:
```sql
FOREIGN KEY (attr1) REFERENCES table_name (attr2_1) ON DELETE <option>
```
Для определения последствий изменения значения, на которое существует ссылка, операцией UPDATE используется опция ON UPDATE. Существуют те же самые опции, которые работают точно также, кроме CASCADE - в случае UPDATE он не удаляет ссылающиеся строки, а изменяет значение внешнего ключа на новое значение атрибута, на который он ссылался.

## Оператор DROP

Оператор DROP позволяет удалить объект из базы данных (в нашем случае - схему или таблицу). По умолчанию в случае, если на таблицу ссылается другой объект базы данных (например, другая таблица), или в схеме содержится таблица, оператор вернет ошибку. Чтобы удалить таблицу и все ссылающиеся на нее объекты, необходимо указать опцию CASCADE:
```sql
DROP SCHEMA schema_name;

DROP SCHEMA schema_name CASCADE;

DROP TABLE table_name;

DROP TABLE table_name CASCADE;
```

## Оператор TRUNCATE

Оператор TRUNCATE используется для полной очистки таблицы. Строки удаляются безвозвратно, но структура таблицы полностью сохраняется. При попытке очистить таблицу, на которую существует ссылка, будет возвращена ошибка как при DROP. Опция CASCADE у TRUNCATE очищает все таблицы, которые ссылаются на очищаемую.
 ```sql
TRUNCATE TABLE table_name;

TRUNCATE TABLE table_name CASCADE;
```

## JOIN в PotgreSQL

Для работы с несколькими таблицами в SQL используются выражения с JOIN (аналог операции соединения из реляционной алгебры). Синтакисис такого выражения:
```sql
table1 join_type table2 [join condition]
```
Выражения с JOIN - это еще один пример источника данных, который можно указать в SELECT-запросе в разделе FROM. Фактически, JOIN формирует виртуальную таблицу, где будут представлены атрибуты обеих таблиц, а содержимое будет зависеть от типа JOIN.\
Рассмотрим виды JOIN, существующие в PostgreSQL:

- CROSS JOIN
Декартово произведение левой и правой таблицы, т.е. строки, составленные из всех возможных пар строк левой и правой таблицы. Не требует условия
- INNER JOIN
Соединение по условию condition - в результат попадают только пары строк, для которых condition возвращает TRUE
- LEFT OUTER JOIN - в результат попадают пары строк, для которых condition возвращает TRUE, а также для каждой строки S из левой таблицы, для которой не нашлось ни одной пары (с выполнением условия) в правой таблице - строка, содержащая в атрибутах левой таблицы атрибуты строки S, а в атрибутах правой таблицы - значения NULL.
- RIGHT OUTER JOIN - аналогично LEFT, только сохраняются значения из правой таблицы, не имеющие пар в левой таблице
- FULL OUTER JOIN - совмещает функционал LEFT и RIGHT, сохраняя "несовпавшие" значения из обеих таблиц

Условие соединения может быть сформулировано разными способами:
- ON condition, где condition - логическое выражение
- USING (attr1, ...) - условие равенства перечисленных одноименных атрибутов в левой и правой таблицах
- NATURAL (указывается перед обозначением вида JOIN, а не после второй таблицы) - условие равенства всех одноименных атрибутов левой и правой таблицы

Создадим таблицу watch, чтобы связать таблицы movies и users:

```sql
CREATE TABLE cinema.watch (
    user_id  INTEGER REFERENCES cinema.users(user_id),
    movie_id INTEGER REFERENCES cinema.movies(movie_id),
    PRIMARY KEY (user_id, movie_id)
);
```
Заполним таблицы данными:
```sql
INSERT INTO cinema.users (email, full_name, birth_date, country) VALUES
('alex@mail.com',  'Alex Stone',  '2000-05-10', 'USA'),
('billy@mail.com', 'Billy Fox',   '1999-02-20', 'UK'),
('chris@mail.com', 'Chris Pine',  '2001-07-01', 'USA'),
('dana@mail.com',  'Dana White',  '1998-11-11', 'Canada');

INSERT INTO cinema.movies VALUES
(10, 'Inception',   2010, 148, 8.8, 'USA'),
(11, 'The Matrix',  1999, 136, 8.7, 'USA'),
(12, 'Amelie',      2001, 122, 8.3, 'France'),
(13, 'Parasite',    2019, 132, 8.5, 'Korea');

INSERT INTO cinema.watch VALUES
(1,10),
(1,11),
(2,11),
(3,13);
```
INNER JOIN:
```sql
SELECT u.full_name, m.title
FROM cinema.users u
INNER JOIN cinema.watch w ON u.user_id = w.user_id
INNER JOIN cinema.movies m ON w.movie_id = m.movie_id
ORDER BY u.full_name;
```

|full_name|title|
|---------|-----|
|Alex Stone|Inception|
|Alex Stone|The Matrix|
|Billy Fox|The Matrix|
|Chris Pine|Parasite|

LEFT OUTER JOIN:
```sql
SELECT u.full_name, m.title
FROM cinema.users u
LEFT OUTER JOIN cinema.watch w ON u.user_id = w.user_id
LEFT OUTER JOIN cinema.movies m ON w.movie_id = m.movie_id
ORDER BY u.full_name;
```
|full_name|title|
|---------|-----|
|Alex Stone|Inception|
|Alex Stone|The Matrix|
|Billy Fox|The Matrix|
|Chris Pine|Parasite|
|Dana White|*NULL*|

RIGHT OUTER JOIN:
```sql
SELECT u.full_name, m.title
FROM cinema.users u
RIGHT OUTER JOIN cinema.watch w ON u.user_id = w.user_id
RIGHT OUTER JOIN cinema.movies m ON w.movie_id = m.movie_id
ORDER BY u.full_name;
```
|full_name|title|
|---------|-----|
|Alex Stone|Inception|
|Alex Stone|The Matrix|
|Billy Fox|The Matrix|
|Chris Pine|Parasite|
|*NULL*|Amelie|

FULL JOIN:

```sql
SELECT u.full_name, m.title
FROM cinema.users u
FULL OUTER JOIN cinema.watch w ON u.user_id = w.user_id
FULL OUTER JOIN cinema.movies m ON w.movie_id = m.movie_id
ORDER BY u.full_name;
```
|full_name|title|
|---------|-----|
|Alex Stone|Inception|
|Alex Stone|The Matrix|
|Billy Fox|The Matrix|
|Chris Pine|Parasite|
|Dana White|*NULL*|
|*NULL*|Amelie|


CROSS JOIN:

```sql
SELECT u.full_name, m.title
FROM cinema.users u
CROSS JOIN cinema.movies m
ORDER BY u.full_name, m.title;
```
|full_name|title|
|---------|-----|
|Alex Stone|Amelie|
|Alex Stone|Inception|
|Alex Stone|Parasite|
|Alex Stone|The Matrix|
|Billy Fox|Amelie|
|Billy Fox|Inception|
|Billy Fox|Parasite|
|Billy Fox|The Matrix|
|Chris Pine|Amelie|
|Chris Pine|Inception|
|Chris Pine|Parasite|
|Chris Pine|The Matrix|
|Dana White|Amelie|
|Dana White|Inception|
|Dana White|Parasite|
|Dana White|The Matrix|

# Практические задания

Пересоздадим схему cinema при помощи скрипта 3_0.sql (для сброса значений serial)

Напомним структуру таблиц
users(user_id, email, full_name, birth_date, country)  
movies(movie_id, title, release_year, duration_min, rating, country)  
watch(user_id, movie_id)

---

### Задание 1
Создайте таблицу genres со столбцами:
- genre_id — целое число, первичный ключ
- name — строка до 100 символов, обязательное, уникальное

---

### Задание 2
Создайте таблицу movie_genres, связывающую фильмы и жанры.  
Требования:

- два столбца - movie_id и genre_id
- составной первичный ключ
- внешние ключи на таблицы movies и genres

---

### Задание 3
Добавьте в таблицу movies столбец created_at типа TIMESTAMP со значением по умолчанию текущего времени (CURRENT_TIMESTAMP).

---

### Задание 4
Измените тип столбца rating так, чтобы он позволял хранить рейтинг с точностью до двух знаков после запятой.

---

### Задание 5
Удалите столбец birth_date из таблицы users.

---

### Задание 6
Добавьте ограничение, запрещающее отрицательную длительность фильма.

---

### Задание 7
Добавьте ограничение, чтобы рейтинг фильма был от 0 до 10 включительно.

---

### Задание 8
Сделайте email пользователя обязательным.

---

### Задание 9
Добавьте уникальное ограничение на пару (title, release_year) в таблице movies

---

### Задание 10
Удалите внешний ключ в таблице watch на таблицу movies, создайте новый с ON DELETE CASCADE.

---

Для дальнейших заданий потребуются данные, вставим их при помощи скрипта 3_1.sql

---

### Задание 11
Выведите список пользователей и названия фильмов, которые они смотрели.

---

### Задание 12
Выведите всех пользователей, включая тех, кто ничего не смотрел.

---

### Задание 13
Выведите все фильмы и пользователей, которые их смотрели.  
Фильмы без просмотров тоже должны быть в результате.

---

### Задание 14
Выведите только пользователей, которые не смотрели ни одного фильма.

---

### Задание 15
Выведите фильмы, которые никто не смотрел.

---

### Задание 16
Создайте таблицу reviews:

- review_id — первичный ключ
- user_id — внешний ключ
- movie_id — внешний ключ
- score — целое число от 1 до 10
- review_text — текст

---

Дополним старые таблицы и заполним новую при помощи 3_2.sql

---

### Задание 17
Напишите запрос, который выводит:

имя пользователя | название фильма | оценка

---

### Задание 18
Выведите фильмы с их средним рейтингом (из таблицы reviews).

---

### Задание 19
Выведите пользователей, которые оценили хотя бы один фильм.

---

### Задание 20
Выведите фильмы, которые никто не оценивал.

